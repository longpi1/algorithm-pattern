动态规划解题思路：

1.dp数组的定义和下标。

2.递推公式。

3.dp数组如何初始化，初始化也需要注意。

4.遍历顺序，比较考究，01 先遍历背包，后遍历物品。

	4.1排列和组合的遍历顺序是不相同的。

	4.1.1 排列：背包在外 物品在内。（322）

	4.1.2 组合：物品在外，背包在内。（518）

5.（出现问题）打印dp数组。（打印dp数组，检查是否有问题，检验1 2 3 4 步骤）


以70题爬楼梯举例子：

动态规划思路：
思路
动规五部曲：
定义一个一维数组来记录不同楼层的状态
确定dp数组以及下标的含义
dp[i]： 爬到第i层楼梯，有dp[i]种方法

确定递推公式
如何可以推出dp[i]呢？

从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 。

在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。

这体现出确定dp数组以及下标的含义的重要性！

dp数组如何初始化
在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。

那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。

例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。

但总有点牵强的成分。

那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.

其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1。

从dp数组定义的角度上来说，dp[0] = 0 也能说得通。

需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。

所以本题其实就不应该讨论dp[0]的初始化！

我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。

所以我的原则是：不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。

确定遍历顺序
从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的


背包问题讲解模板：

滚动数组（Rolling Array），也称为滑动数组（Sliding Array）或循环数组（Circular Array），是一种用于优化内存使用的数据结构技巧。它的基本思想是在一个有限大小的数组或缓冲区中存储数据，当需要添加新数据时，新数据会覆盖掉旧数据，以保持数组的大小不变。这种技巧通常用于处理动态规划问题中的状态转移，降低了内存消耗，尤其适用于只需要存储一部分之前的状态信息的问题。

滚动数组的优势在于避免了创建和维护大型的动态规划表格或二维数组，从而减少了内存占用。它通常用于那些只需要访问前一行或前一列数据的问题，而不需要保留整个表格的情况。通过滚动数组，只需要存储两个一维数组，一个用于当前层状态，一个用于上一层状态，然后在迭代过程中交替更新这两个数组，以实现状态转移。

滚动数组在一些经典的动态规划问题中非常有用，例如0/1背包问题、斐波那契数列、最长公共子序列等。通过减少内存占用，它可以帮助提高程序的效率和性能，特别是在处理大规模问题或内存受限的情况下。
	
func knapsack(values, weights []int, capacity int) int {
	n := len(values)
	dp := make([][]int, n+1)

	for i := range dp {
		dp[i] = make([]int, capacity+1)
	}

	// 填充动态规划表
	for i := 1; i <= n; i++ {
		for w := 1; w <= capacity; w++ {
			// 如果当前物品的重量小于等于当前背包容量
			if weights[i-1] <= w {
				// 可以选择放入当前物品或不放入当前物品，取较大的值
				dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
			} else {
				// 当前物品的重量大于当前背包容量，无法放入
				dp[i][w] = dp[i-1][w]
			}
		}
	}

	// 返回最大总价值
	return dp[n][capacity]
}


终于搞懂为啥要倒叙遍历了。

首先要明白二维数组的递推过程，然后才能看懂二维变一维的过程。

假设目前有背包容量为10，可以装的最大价值， 记为g(10)。

即将进来的物品重量为6。价值为9。
那么此时可以选择装该物品或者不装该物品。

如果不装该物品，显然背包容量无变化，这里对应二维数组，其实就是取该格子上方的格子复制下来，就是所说的滚动下来，直接g【10】 = g【10】，这两个g【10】要搞清楚，右边的g【10】是上一轮记录的，也就是对应二维数组里上一层的值，而左边是新的g【10】，也就是对应二维数组里下一层的值。

如果装该物品，则背包容量= g(10-6) = g(4) + 9 ，也就是 g(10) = g(4) + 6 ,这里的6显然就是新进来的物品的价值，g(10)就是新记录的，对应二维数组里下一层的值，而这里的g(4)是对应二维数组里上一层的值，通俗的来讲：你要找到上一层也就是上一状态下 背包容量为4时的能装的最大价值，用它来更新下一层的这一状态，也就是加入了价值为9的物品的新状态。

这时候如果是正序遍历会怎么样？ g(10) = g(4) + 6 ，这个式子里的g(4)就不再是上一层的了，因为你是正序啊，g(4) 比g(10)提前更新，那么此时程序已经没法读取到上一层的g(4)了，新更新的下一层的g(4)覆盖掉了，这里也就是为啥有题解说一件物品被拿了两次的原因。

func knapsack(values, weights []int, capacity int) int {
    n := len(values)
    // 创建两个一维数组，用于当前层和上一层状态
    dp := make([]int, capacity+1)
    dpPrev := make([]int, capacity+1)

    for i := 1; i <= n; i++ {
        for j := 1; j <= capacity; j++ {
            if weights[i-1] <= j {
                dp[j] = max(dpPrev[j], dpPrev[j-weights[i-1]]+values[i-1])
            } else {
                dp[j] = dpPrev[j]
            }
        }
        // 更新上一层状态为当前层状态
        copy(dpPrev, dp)
    }

    return dp[capacity]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

