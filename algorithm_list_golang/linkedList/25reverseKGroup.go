package main

/*
25. K 个一组翻转链表
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

示例 1：
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
示例 2：
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]

*/

/*
做题顺序，反转链表，反转链表2，K 个一组翻转链表
解题思路：
统计节点个数： 遍历链表统计节点个数，用于确定翻转的次数。
初始化虚拟头节点和指针： 使用虚拟头节点 dummy 辅助操作，并初始化指针 p0 为虚拟头节点。
翻转 k 个节点：
循环 k 次，将当前节点 cur 的 Next 指向前一个节点 pre，实现局部翻转。
每次循环只修改一个 Next 指针，以便于理解和调试。
连接翻转后的 k 个节点：
将翻转后的 k 个节点连接回链表，注意连接的顺序，确保链表的连续性。
p0.Next.Next = cur 将当前翻转后的尾节点连接剩余的节点。
p0.Next = pre 将当前翻转后的头节点连接上一个 k 个节点翻转后的尾节点。
更新指针和循环条件： 更新指针 p0 为下一个 k 个节点翻转前的头节点，减少剩余节点的数量。循环条件 n >= k 确保剩余节点数足够进行下一次翻转。
返回翻转后的链表头节点： 返回虚拟头节点的 Next 指针，即为翻转后的链表头节点。
*/

func reverseKGroup(head *ListNode, k int) *ListNode {
	n := 0
	for cur := head; cur != nil; cur = cur.Next {
		n++ // 统计节点个数
	}

	dummy := &ListNode{Next: head}
	p0 := dummy
	var pre, cur *ListNode = nil, p0.Next
	for ; n >= k; n -= k {
		for i := 0; i < k; i++ {
			nxt := cur.Next
			cur.Next = pre // 每次循环只修改一个 Next，方便大家理解
			pre = cur
			cur = nxt
		}

		// 将翻转后的 k 个节点连接回链表，注意连接的顺序
		nxt := p0.Next // 记录当前 k 个节点翻转前的头节点
		p0.Next.Next = cur // 当前翻转后的尾节点连接剩余的节点
		p0.Next = pre // 当前翻转后的头节点连接上一个 k 个节点翻转后的尾节点
		p0 = nxt // 更新 p0 为下一个 k 个节点翻转前的头节点
	}
	return dummy.Next // 返回翻转后的链表头节点
}
