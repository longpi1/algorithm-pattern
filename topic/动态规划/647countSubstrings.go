package main

/*
647. 回文子串
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。
子字符串 是字符串中的由连续字符组成的一个序列。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

示例 1：
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
*/
/*
有时我们想到动态规划，但不知从何入手，可以试试这么想：

大问题是什么？
规模小一点的子问题是什么？
它们之间有什么联系？
大问题是一个子串是否是回文串，然后统计有几个回文子串，那规模小一点的子问题呢？
一个子串是回文串，刨去相同的首尾字符，剩下的子串也必须是回文串。
剩下的子串是否为回文串，就是规模小一点的子问题，它影响大问题的结果。
子串的首尾索引 i 、j 是描述子问题的变量，s[i:j] 是否是回文串，是 dp 子问题。

用二维 Boolean 数组记录中間子问题的解，从base case出发，递推出每个子问题的解。

别忘了需满足 i<=j，所以只用填半个 table，如图：

s[i:j] 什么时候是回文？（dp[i][j]为 true），我们罗列一下：

由单个字符组成。（上图打钩的格子）
由 2 个字符组成，且字符要相同。（1、2 是base case，不需要用到递推公式）
由超过 2 个字符组成，首尾字符相同，且剩余子串是一个回文串。（状态转移方程）
时间复杂度：O(n2)空间复杂度：O(n2)

作者：笨猪爆破组
链接：https://leetcode.cn/problems/palindromic-substrings/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/




func countSubstrings(s string) int {
	n := len(s)
	dp := make([][]bool, n)
	result := 0
	for i := 0; i <n ; i++ {
		dp[i] = make([]bool, n)
	}

	for j := 0; j < n; j++ {
		for i := 0; i <= j ; i++ {
			if s[i] == s[j] && (j-i <2 || dp[i+1][j-1]) {
				dp[i][j] = true
				result++
			}
		}
	}
	return result
}






func countSubstrings(s string) int {
	res := 0 // 用于计算回文子串的数量
	dp := make([][]bool, len(s)) // 创建一个二维动态规划数组，dp[i][j]表示从索引i到j的子串是否是回文子串
	for i := 0; i < len(s); i++ {
		dp[i] = make([]bool, len(s))
	}
	// 别忘了需满足 i<=j，所以只用填半个 table
	for j := 0; j < len(s); j++ {
		for i := 0; i <= j; i++ {
			// 检查字符串s中索引i到j的子串是否是回文子串
			if s[i] == s[j] {
				if j-i <= 1 {
					// 如果子串长度为1或2，直接为回文子串
					res++
					dp[i][j] = true
				} else if dp[i+1][j-1] {
					// 如果子串长度大于2，且内部的子串也是回文子串，则为回文子串
					res++
					dp[i][j] = true
				}
			}
		}
	}
	return res // 返回回文子串的数量
}
